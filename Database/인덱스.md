# 📎 인덱스란?

인덱스는 데이터베이스 테이블에 대한 **검색 성능의 속도를 높여주는 자료구조**이다.  
특정 컬럼에 인덱스를 생성하면, 해당 컬럼의 데이터를 정렬하여 별도의 메모리 공간에 **데이터의 물리적 주소와 함께 저장**된다.  
인덱스는 기본적으로 **오름차순으로 정렬**되므로 **정렬된 주소체계**라고도 표현할 수 있다.

인덱스를 **책의 목차**에 비유하면 이해하기 쉽다.  
- **데이터**: 책의 내용  
- **인덱스**: 책의 목차  
- **물리적 주소**: 책의 페이지 번호  

책의 내용을 찾을 때 목차나 색인을 이용하면 빠르게 찾을 수 있듯이, 테이블에서도 인덱스를 활용하면 원하는 데이터를 빠르게 검색할 수 있다.

---

## 📌 2. 인덱스의 자료구조

인덱스는 여러 자료구조를 통해 구현할 수 있으며, 대표적인 자료구조는 **해시 테이블(Hash Table)**과 **B+Tree**이다.

### 📎 해시 테이블 (Hash Table)
해시 테이블은 컬럼의 값과 물리적 주소를 **(key, value)** 쌍으로 저장하는 자료구조이다.  
하지만 실제 인덱스 구현에서는 **잘 사용되지 않는다.**  
- **장점**: 등호(=) 연산에 최적화되어 있다.  
- **단점**: 부등호(<, >) 연산을 지원하지 못한다.  
  - 데이터가 정렬되어 있지 않으므로 특정 기준보다 크거나 작은 값을 빠르게 찾을 수 없다.
 
![images_alicesykim95_post_21578204-a137-4e99-8017-263c441c1bab_다운로드](https://github.com/user-attachments/assets/20dd96e5-3450-48bf-8232-26b7ff488d9a)


### 📎 B+Tree
B+Tree는 대부분의 DBMS, 특히 오라클에서 중점적으로 사용되는 가장 보편적인 인덱스이다.  
- **구조**: Root Node(기준), Branch Node(중간), Leaf Node(말단)로 구성된 계층적 구조.  
- **특징**:
  - Leaf Node만 인덱스(Key)와 데이터(Value)를 저장.
  - Leaf Node들끼리는 LinkedList로 연결되어 효율적인 데이터 접근 가능.
  - Root Node에서 원하는 데이터가 저장된 Leaf Node까지 경로를 따라 이동.
    
![images_alicesykim95_post_0fb18bd7-8665-409f-8f60-1f489faca837_다운로드 (1)](https://github.com/user-attachments/assets/1e986a13-13dc-4650-b1e2-e5f20e9dd798)

---

## 📌 3. 인덱스의 장단점

### 📎 장점: 인덱스를 사용하는 이유
1. **검색과 정렬 속도 향상**:
   - 인덱스를 통해 데이터가 정렬되어 있어 효율적인 검색 및 정렬 가능.
2. **조건 검색(Where 절) 효율성**:
   - 특정 조건에 맞는 데이터를 빠르게 검색 가능.
3. **정렬(Order By) 최적화**:
   - 추가적인 정렬 과정 없이 데이터를 바로 반환.
4. **MIN, MAX 함수 효율성**:
   - 정렬된 데이터에서 최소값과 최대값을 빠르게 추출.
5. **테이블 행의 고유성 강화**:
   - 고유 키(unique key) 제약 조건과 같은 역할 수행.
6. **시스템 부하 감소**:
   - 쿼리 실행 시 필요한 리소스를 줄여 전체적인 성능 향상.

### 📎 단점: 인덱스 사용 시 주의할 점
1. **정렬 유지 부하**:
   - 인덱스 컬럼에서 `INSERT`, `UPDATE`, `DELETE` 발생 시 정렬 상태를 유지해야 하므로 추가적인 작업이 필요.
     - `INSERT`: 새로운 데이터에 대한 인덱스 추가.
     - `DELETE`: 삭제된 데이터의 인덱스를 사용하지 않음 처리.
     - `UPDATE`: 기존 인덱스를 제거 후, 갱신된 데이터에 대해 인덱스 추가.
2. **무조건 인덱스 스캔이 유리하지 않음**:
   - 소량의 데이터가 포함된 테이블에서는 풀 스캔이 더 빠를 수 있음.
3. **인덱스 과다 생성**:
   - 인덱스 관리에는 추가적인 저장공간이 필요(데이터베이스의 약 10%).
   - 과도한 인덱스는 전체적인 성능 부하를 초래할 수 있음.

---

### 📎 인덱스를 효과적으로 사용하기 위해:
- 검색 빈도가 높은 컬럼에만 인덱스를 생성.
- 인덱스 생성은 SQL 최적화 후 **최후의 수단**으로 고려.
