# 메모리 관리: 페이징(Paging)과 세그먼테이션(Segmentation)

## 개요
다중 프로그래밍 시스템에서 다수의 프로세스를 수용하기 위해 주기억장치를 동적으로 분할하는 메모리 관리 작업이 필요합니다. 
단일 프로그램만 사용하는 것이 아니기 때문에 이를 어떻게 메모리에 적재할 것인지 고려해야 하며, 이 과정에서 페이징과 세그먼테이션과 같은 메모리 관리 기법을 활용합니다.

---

## 메모리 관리 기법

### 1. 연속 메모리 관리
- **프로그램 전체를 하나의 커다란 공간에 연속적으로 할당**해야 하는 방식입니다.
  
#### 고정 분할 기법
- 주기억장치를 고정된 파티션으로 분할
- 내부 단편화 발생

#### 동적 분할 기법
- 파티션이 동적으로 생성되며 자신의 크기와 같은 파티션에 적재
- 외부 단편화 발생

![image](https://github.com/user-attachments/assets/6645bedb-742c-4f36-88ed-cfc39fddd5a0)

#### 단편화
- **내부 단편화**
-  프로세스가 사용하는 메모리 공간에 남는 부분
-  프로세스가 요청한 양보다 더 많은 메모리를 할당할 때 발생하며, 메모리 분할 자유 공간과 프로세스가 사용하는 공간의 크기 차이를 의미함
  
![image (1)](https://github.com/user-attachments/assets/9828d719-e0f8-4581-9814-337f59d4cd4d)

- **외부 단편화**
- 메모리 공간 중 사용하지 못하게 되는 부분
- 메모리 할당 및 해제 작업의 반복으로 작은 메모리가 중간 중간 존재할 수 있음, 이렇게 사용하지 않는 메모리가 존재해서 총 메모리 공간은 충분하지만 실제로 할당할 수 없는 상황임
- 외부 단편화를 해결하기 위해 압축을 이용하여 프로세스가 사용하는 공간을 한쪽으로 몰 수 있지만, 작업 효율이 좋지는 않음

![image (2)](https://github.com/user-attachments/assets/ae63c91e-6bc2-4381-9714-078dbd4e5f74)

---

### 2. 불연속 메모리 관리
- 프로그램 일부가 서로 다른 주소 공간에 할당될 수 있는 방식으로, 단편화 문제를 해결하기 위한 기법입니다.
- 대표적으로 **페이징(Paging)**과 **세그먼테이션(Segmentation)**이 있습니다.

---

## 페이징(Paging)
- 프로세스를 일정한 크기의 페이지로 분할해서 메모리에 적재하는 방식임
- 하나의 프로세스가 사용하는 메모리 공간이 연속적이어야 한다는 제약을 없애는 메모리 관리 방법임

### 구성 요소
- **페이지(page)**: 작은 고정 크기의 프로세스 조각
- **프레임(frame)**: 페이지와 동일한 크기를 가지는 물리적 메모리 조각
- **페이지 테이블**: 프로세스의 각 페이지에 해당하는 프레임 위치를 관리

![image (3)](https://github.com/user-attachments/assets/36e0b5e7-38f1-4179-baee-f8db792eaaf7)

- 물리 메모리는 고정 크기의 프레임으로, 가상 메모리는 고정 크기의 페이지로 분리되어 있음
- 개별 페이지는 순서에 상관없이 물리 메모리에 있는 프레임에 매핑되어 저장됨
- 모든 프로세스는 하나의 페이징 테이블을 가지고 있으며, 여기에는 메인 메모리에 적재되어 있는 페이지 번호와 해당 페이지가 위치한 메인 메모리의 시작 주소가 있음
- 이를 통해 하나의 프로세스를 나눈 가상 메모리 페이지들이 각각 실제 메인 메모리의 어디 프레임에 적재되어 있는지 알아낼 수 있음

![image (5)](https://github.com/user-attachments/assets/faf86a21-6b13-4b68-b7dd-a35ee0c00f63)

- 위의 페이징 테이블에서는 P1프로세스의 0번째 페이지가 메인 메모리의 5번째 프레임에 있는 것을 알 수 있음

### 논리 주소와 페이지 테이블
- 메모리 관리 장치(MMU)에선 가상 주소(논리 주소)를 이용해 실제 데이터가 담겨 있는 주소로 변환을 해주는데
  논리 주소는 <page, offset>과 같은 형태로 구성되는데 이를 이용해 물리 주소로 변환해 주는 것임

### 페이징의 장단점
- **장점**
  - 외부 단편화 발생하지 않음
  - 메모리가 연속적이지 않아도 적재 가능
- **단점**
  - 내부 단편화 문제 발생 가능
  - 페이지 매핑 과정이 복잡해질 수 있음

---

## 세그먼테이션(Segmentation)
- 가상 메모리를 서로 크기가 다른 논리적 단위로 분할한 것을 의미함
- 프로세스를 물리적 단위인 페이지가 아닌 논리적 단위인 세그먼트로 분할해서 메모리에 적재하는 방식임
- 세그먼트는 의미가 같지 않는 논리적 내용을 기준으로 프로그램을 분할하기 때문에 크기가 같지 않음

![image (6)](https://github.com/user-attachments/assets/9acae535-db23-4768-9e53-4b9374b9ca9f)

### 구성 요소
- **세그먼트(segment)**: 크기가 다른 논리적 블록
- **세그먼트 테이블**: 세그먼트 번호, 시작 주소(base), 한계(limit) 관리

### 논리 주소와 세그먼트 테이블
- 분할 방식을 제외하고 페이징과 세그먼테이션이 동일하기 때문에 매핑 테이블의 동작 방식도 동일함
- 논리 주소의 앞 비트들은 페이징 번호가 아닌 세그먼트 번호가 됨 <segment, offset> 형태로 구성되고
  세그먼트 번호를 통해 세그먼트의 기준(세그먼트의 시작 물리 주소)와 한계(세그먼트의 길이)를 파악할 수 있음

### 세그먼테이션의 장단점
- **장점**
  - 내부 단편화 문제 해소
  - 보호와 공유 기능 지원
  - 중요한 부분과 중요하지 않은 부분 분리 가능
- **단점**
  - 외부 단편화 문제 발생 가능

---

## 페이징과 세그먼테이션 비교

| 구분                     | 페이징(Paging)                                    | 세그먼테이션(Segmentation)                       |
|--------------------------|--------------------------------------------------|------------------------------------------------|
| **크기**                | 고정 크기                                         | 가변 크기                                      |
| **단편화 문제**          | 외부 단편화 없음, 내부 단편화 발생 가능           | 내부 단편화 없음, 외부 단편화 발생 가능        |
| **주소 형태**           | `<page, offset>`                                 | `<segment, offset>`                           |
| **메모리 관리 효율**     | 논리적 메모리와 물리적 메모리 매핑으로 효율적      | 논리적 단위 분리로 효율적                      |

---

## 가상 메모리 기법
- **가상 메모리 페이징**: 필요한 페이지만 로드하여 외부 단편화 문제를 해결
- **가상 메모리 세그먼테이션**: 필요한 세그먼트만 로드하여 내부 단편화 문제를 해결

| 구분                     | 가상 메모리 페이징                              | 가상 메모리 세그먼테이션                        |
|--------------------------|----------------------------------------------|----------------------------------------------|
| **로드 방식**            | 필요한 페이지만 자동으로 불러옴                 | 필요한 세그먼트만 자동으로 불러옴              |
| **단편화 문제**          | 외부 단편화 없음                              | 내부 단편화 없음                              |
| **오버헤드**             | 복잡한 메모리 관리로 인한 오버헤드 발생          | 복잡한 메모리 관리로 인한 오버헤드 발생         |

---
