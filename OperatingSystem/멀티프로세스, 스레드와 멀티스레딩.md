# 멀티프로세스, 스레드와 멀티스레딩

## 프로세스

프로그램이 실행중인 상태

디스크에 저장된 프로그램이 RAM에 로드된 후, CPU에서 실행되면서 운영 체제에 의해 관리되는 실행 단위

운영체제는 프로세스에 가상 메모리 할당

## **멀티프로세스**

여러 개의 독립적인 프로세스가 동시에 실행되는 방식

**프로세스 당 하나의 가상 메모리**

**장점:**

- 안정성이 높음. 하나의 프로세스에 문제가 생겨도 다른 프로세스에 영향 없음
- 각 프로세스가 독립된 메모리 공간을 가지므로 보안성 높음

**단점:**

- 프로세스 간 통신(IPC)에 추가적인 오버헤드 발생(컨텍스트 스위칭, 직렬화 역직렬화 등)
- 메모리 사용량 높음. 각 프로세스가 독립된 메모리 공간을 가지므로 같은 데이터가 중복 저장되는 문제가 있을 수 있음

## 스레드

스레드는 프로세스 내에서 실행되는 작업의 최소 단위

하나의 프로세스 내의 여러 개의 스레드는 **가상 메모리 공유**

**멀티 스레딩** : 

하나의 프로세스 내에서 여러 스레드를 생성하여 동시에 작업을 수행하는 방식

**장점:**

- 메모리 효율성이 높음. 스레드들이 프로세스의 메모리를 공유하므로 자원을 효율적으로 사용
- 컨텍스트 스위칭 비용 낮음. 프로세스 전환보다 스레드 전환이 더 빠름
- 스레드 간 통신이 간단

**단점:**

- 동기화 문제, 여러 스레드가 공유 자원에 동시에 접근할 때 데이터 일관성 문제가 발생 가능
- 하나의 스레드에 문제가 생기면 전체 프로세스에 영향을 줄 수 있음 (스레드 간 자원을 공유하므로 해당 자원이 손상되면 그 자원에 접근하려는 다른 스레도 영향을 받음)
- **프로세스와 스레드의 컨텍스트 스위칭 차이**
    
    
    | **항목** | **프로세스 컨텍스트 스위칭** | **스레드 컨텍스트 스위칭** |
    | --- | --- | --- |
    | **저장 상태** | - CPU 레지스터 상태
    - 프로세스의 가상 메모리 정보(Page Table)
    - 커널 스택 상태 | - CPU 레지스터 상태
    - 스레드별 고유 스택 상태 |
    | **메모리 교체** | 가상 메모리(Page Table) 교체가 필요 | 동일한 프로세스 내 스레드라면 메모리 교체 불필요 |
    | **비용** | 더 높은 오버헤드 발생 | 상대적으로 낮은 오버헤드 |
    | **속도** | 느림 (메모리 매핑, TLB 초기화 포함) | 빠름 (공유 메모리 공간 사용) |

### 동시에 실행?

cpu는 한 번에 하나의 작업만 처리

단일 코어에서 멀티 스레딩을 한다는 것은 스위칭을 통해 동시에 일어나는 것처럼 착각

- 성능 저하 : context switching은 현재 실행중인 스레드의 상태를 저장하고 다음에 실행한 스레드를 로드해야되는 비용 발생
- 최적화된 성능 : 멀티 코어라면 하나의 코어당 하나의 스레드를 할당하는 것이 이상적

### Block I/O가 발생하는 환경

- 하드디스크
    - HDD는 물리적으로 디스크 플래터를 회전
    - 헤드를 움직여 해당 데이터가 위치한 섹터로 접근
    - 수 밀리초 이상의 탐색 시간이 소요
    - 스레드는 디스크로부터 응답이 올 때까지 대기(Blocking)
    
    **스레드 다중화의 이점**
    
    - 가정 : CPU 코어 수보다 더 많은 스레드 존재
    - 다른 스레드들이 Blocking 되면 CPU는 대기하지 않는 스레드를 실행
- **Spring Web MVC + JDBC(JPA 등)**
    - 스레드가 DB 쿼리 실행
    - DB 결과가 반환될 때까지 스레드는 Blocking
    - 결과를 받으면 다음 로직을 처리하고 응답을 반환
    
    이런 환경에선 thread가 cpu 코어수를 초과하는 경우 효율적
    
- 정리 : Block I/O인 경우, Thread는 CPU 코어 수보다 많으면 좋다
    - 최적의 Thread 수?
        
        최적의 연결 수 계산 공식(PostgreSQL이 제시한 DB 활성 커넥션 수)
        
        **활성 커넥션 수 = ((CPU 코어 수 * 2) + 유효 스핀들 수)**
        
        - ex) 하드 디스크가 1개, 4코어 i7 서버 ⇒ **9 = ((4 * 2) + 1)**
            
            최적의 DB Connection pool = 9 
            

## **적용 사례**

- 멀티프로세스: 웹 브라우저의 탭 분리, 데이터베이스 서버 등 안정성이 중요한 시스템에 적합
- 멀티스레딩: 웹 서버, 게임 서버, 실시간 데이터 처리 시스템 등 리소스를 효율적으로 사용해야 하는 경우에 적합