# 주소 공간(Address Space)

### 메모리 내 주소 체계

![](/OperatingSystem/images/address.jpg)

1. 논리 주소 (CPU와 실행중인 프로그램 입장에서 바라본 주소) <br>
2. 물리 주소 (실제 하드웨어 번지)

<br>

### CPU와 실행 중인 프로그램은 현재 메모리 몇 번지에 무엇이 저장되어 있는지 다 알고 있을까?

**∴모름**

- 메모리의 저장된 값들은 시시각각 변함
  - 새롭게 실행되는 프로그램은 새롭게 메모리에 적재
  - 실행이 끝난 프로그램은 메모리에서 삭제
  - 같은 프로그램을 실행하더라도 실행할 때마다 적재되는 주소는 달라짐 <br>

➡ 이러한 것들을 극복하기 위해 주소 체계를 **물리 주소 / 논리 주소**로 나눔

<br>
<br>

## 물리 주소 / 논리 주소

![](/OperatingSystem/images/address2.jpg)
<br>

### 물리 주소

- 메모리 입장에서 바라본 주소
- 말 그대로 정보가 실제로 저장된 하드웨어상의 주소

### 논리 주소

- CPU와 실행 중인 프로그램 입장에서 바라본 주소
- CPU가 실행하고 이해하는 주소
- 실행 중인 프로그램 각각에게 부여된 0번지부터 시작하는 주소
- 프로그램 시작점으로부터 얼마나 떨어져 있는지에 해당하는 정보

<br>

![](/OperatingSystem/images/address3.jpg)
<br>

- 100번지는 논리 주소 상에서 n개 존재 가능하지만 물리 주소 상에서는 하나뿐임, 겹치는 주소 번지가 없음

<br>
<br>

## 물리 주소와 논리 주소의 변환

![](/OperatingSystem/images/address4.jpg)

- CPU가 메모리와 상호작용을 하려면 결국 **논리주소→물리주소** 변환 과정이 필요함

<br>

### MMU(Memory Management Unit, 메모리 관리 장치)

![](/OperatingSystem/images/address5.jpg)

- CPU와 메모리 사이에 있는 MMU라는 하드웨어에 의해 변환
- 논리 주소를 주소 버스를 통해 실제 메모리에 보내거나, 메모리에서 주소 버스를 통해 받은 주소 번지를 CPU로 갖고 올 땐 항상 MMU를 거침
- MMU는 **논리 주소와 베이스 레지스터 값(프로그램의 기준 주소/첫 물리 주소)을 더하여** 물리 주소로 변환
  - 베이스 레지스터 안에는 프로그램의 시작 주소가 담겨있음 (물리 주소 상의 시작 주소) <br>

EX)
![](/OperatingSystem/images/address6.jpg)

- 논리 주소 상의 프로그램 A의 100번지 데이터 삭제
  - 프로그램 A : 물리 주소 상(메모리)에서 15000~30000번지에 저장되어 있음
  - 베이스 레지스터(기준 주소) : 15000
  - 논리 주소=100 : 기준 주소로부터 100만큼 떨어진 곳
    **➡ 실제 15100번지 삭제**

<br>

## 🤔다른 프로그램의 영역을 침범하는 명령어를 실행한다면?

: **X** <br>
![](/OperatingSystem/images/address7.jpg)

<br>

## 메모리 보호

### 한계 레지스터

![](/OperatingSystem/images/address8.jpg)

- 프로그램의 영역을 침범할 수 있는 명령어의 실행을 막음
- 베이스 레지스터가 실행 중인 프로그램의 가장 작은 물리 주소를 저장한다면, 한계 레지스터는 논리 주소의 최대 크기를 저장
- **베이스 레지스터 값 ≤ 프로그램의 물리 주소 범위 < 베이스 레지스터 + 한계 레지스터 값**

<br>

![](/OperatingSystem/images/address8.jpg)

- CPU는 메모리에 접근하기 전에 논리 주소가 한계 레지스터보다 작은지 항상 검사
- 실행 중인 프로그램의 독립적인 실행 공간 확보
- 하나의 프로그램이 다른 프로그램을 침범하지 못하게 보호

<br>

---

<br>

# 가상 메모리(Virtual Memory)

: 메모리가 실제 메모리보다 많이 보이게 운영체제가 제공하는 기술

- 물리적 메모리 한계에도 불구하고 더 많은 양을 가진 프로그램을 실행시킬 수 있음
- 시스템이 프로그램을 실행시키는데 최소 얼마만큼의 메모리가 필요한가에 대한 접근 방식으로, 실행헤 필요한 일부분만 메모리에 로드하고 나머지는 디스크에 두고 필요할 때마다 교체하면서 쓰는 방식으로 구현

<br>

### 가상 메모리 장점

- 메인 메모리를 하드디스크의 캐시로 처리하여 더 넓은 메모리 공간 제공
  - 임시 데이터를 하드디스크 드라이브에 저장하고 필요에 따라 기본 메모리로 가져올 수도 있음
- 메모리 크기의 제약으로부터 자유로움
  - 실행에 필요한 최소 크기의 메모리만 올라가져 있기 때문에 더 많은 프로그램 동시 수행 가능
- 추가 권한 비트를 사용하여 각 프로세스의 메모리에 대한 제한된 액세스 권한으 부여하여 메모리 보호
  - 권한 비트를 확인하여 다른 프로세스의 메모리 공간을 손상시키지 않도록 함

<br>

## 요구 페이징(Demand Paging)

- **필요한 부분만 요청이 있을 때** 물리적 메모리에 페이지단위로 적재하는 방법 (페이징은 모든 페이지를 메모리에 적재한 후 실행)
- 특정 페이지에 대해 CPU요청이 들어오면 해당 페이지를 메모리에 적재
  ![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fzm4CO%2FbtsyExK0Ksl%2Fcd3kpMNkxzFxldYZU6diak%2Fimg.png)

<br>

**EX)**
OS에 실행 중인 모든 프로그램을 저장하기 위해 300MB 필요 <br>
현재 RAM에 사용 가능한 물리적 메모리 50MB <br>
프로그램 전체를 RAM에 올릴 수 없기 때문에 가상메모리와 요구페이징 기법 필요<br>

##### 가상 메모리 설정

- OS는 250MB의 가상 메모리를 설정
- VMM(Virtual Memory Manager)로 250MB를 관리
  - VMM은 250MB 크기의 파일을 디스크에 생성
  - 물리 메모리(50MB)와 가상 메모리(250MB)를 조합해 300MB의 메모리를 관리
  - 필요한 데이터를 RAM(50MB)과 디스크(250MB) 사이에서 효율적으로 이동시킴
- OS는 50MB의 공간만 사용할 수 있더라도 300MB의 메모리를 고려하므로 메모리 주소 지정 계속 가능

##### 요구 페이징 동작

- 프로그램의 300MB 중 지금 당장 실행에 필요한 데이터만 50MB의 RAM에 올림
- 프로그램의 나머지 데이터는 가상 메모리(디스크) 공간에 저장되며 필요할 때 RAM으로 이동

##### 결론

- 제한된 RAM(50MB)으로도 더 큰 프로그램(300MB)을 실행 가능
